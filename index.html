<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title></title>
</head>

<body>
	<button id="calculate">Calculate</button>
	<div id="status">&nbsp;</div>
	<div class="display">
		<div>
			<canvas id="canvas-worker" width="900" height="500"></canvas>
		</div>
		<div>
			<img src="http://localhost:5255/stream/stream2" width="900" height="500">
		</div>
	</div>
	<script id="worker-script"> // type="script/worker"
		function findSubarray(arr, subarr) {
			for (var i = 0; i < 1 + (arr.length - subarr.length); i++) {
				var j = 0;
				for (; j < subarr.length; j++)
					if (arr[i + j] !== subarr[j])
						break;
				if (j == subarr.length)
					return i;
			}
			return -1;
		}
		function mergeTypedArrays(a, b) {
			if(!b || b.length === 0) return a;
			if(!a || a.length === 0) return b;
			var c = new a.constructor(a.length + b.length);
			c.set(a);
			c.set(b, a.length);
			return c;
		}
		class MyWorker {
			constructor(ctx) {
				this.ctx = ctx;
				this.run = false;
			}

			stop() {
				this.run = false;
			}

			start() {
				this.run = true;
				//this.animate();
				// var offset = 0;
				// var r = new XMLHttpRequest();
				// // r.open('GET', 'http://localhost:5255/stream/stream2', true);
				// r.onreadystatechange = function (e) {
				// 	console.log(r.responseText.length)
				// }
				// r.send();
				
				fetch('http://localhost:5255/stream/stream2').then((res)=>{
					const reader = res.body.getReader()
					var buffer = new Uint8Array()
					const boundary = [45, 45, 106, 112, 103, 98, 111, 117, 110, 100, 97, 114, 121, 13, 10]
					const read = () => {
						reader.read().then(async (part)=>{
							let current = part.value
							let position = findSubarray(part.value, boundary)
							while (position > -1) {
								if (position > 0) {
									buffer = mergeTypedArrays(buffer, current.subarray(0, position))
								}
								if (buffer.length > 0) {
									const rnPosition = findSubarray(buffer, [13, 10, 13, 10])
									const blob = new Blob([buffer.subarray(rnPosition+4)], {type: 'image/jpeg'})
									const bitmap = await createImageBitmap(blob)
									this.ctx.drawImage(bitmap, 0, 0, 900, 500);
									bitmap.close()
									buffer = new Uint8Array()
								}
								current = current.subarray(position+boundary.length)
								position = findSubarray(current, boundary)
							}
							buffer = mergeTypedArrays(buffer, current)
							if(this.run) {
								read()
							}
						})
					}
					read()
				})
			}
		}
		let worker = null;
		self.onmessage = function(e) {
		switch (e.data.msg) {
			case 'start':
			if (!worker) {
				worker = new MyWorker(e.data.canvas.getContext('2d'));
			}
			worker.start();
			break;
			case 'stop':
			worker.stop();
			break;
		}
		};
  	</script>
	<script>
		(async () => {

			function fib(num) {
				return (num <= 1) ? 1 : fib(num - 1) + fib(num - 2);
			}

			document.querySelector('#calculate').addEventListener('click', () => {
				document.querySelector('#status').innerText = 'Calculating on main thread';
				requestAnimationFrame(() => {
					requestAnimationFrame(() => {
						fib(40);
						document.querySelector('#status').innerText = 'Done!';
					});
				})
			});

			const workerCode = document.querySelector('#worker-script').textContent;
			const blob = new Blob([workerCode], { type: 'text/javascript' });
			const url = URL.createObjectURL(blob);
			const worker = new Worker(url);

			const offscreen = document.querySelector('#canvas-worker').transferControlToOffscreen();
			const urlParts = location.href.split('/');
			if (urlParts[urlParts.length - 1].indexOf('.') !== -1) {
				urlParts.pop();
			}
			worker.postMessage({ msg: 'start', origin: urlParts.join('/'), canvas: offscreen }, [offscreen]);
			URL.revokeObjectURL(url); 
		})();


	</script>
</body>

</html>